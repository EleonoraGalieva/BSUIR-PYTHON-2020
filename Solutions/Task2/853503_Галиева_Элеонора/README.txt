Python 3.8.1

В прикреплении находится архив, который демонстрирует работоспособность созданного нами пакета и самой лабораторной работы.
В начале нужно распаковать архив и перейти в папку проекта.Далее прописываем в терминале python setup.py install. После этого мы можем перейти в модуль main.py
в котором продемонстрированы накоторые задания лабараторной работы. 
Все модули, кроме setup.py, находятся в каталоге Lab2.



1. Реализована сортировка слиянием по внешней памяти. Исходный файл разбивается на несколько временных файлов, которые по отдельности сортируются. 
Их имена записываются в список. Затем из этого списка берутся по 2 файла, которые сливаются в один. Использованные два файла удаляются. 
Так происходит до тех пор, пока не будут «слиты» все файлы из списка временных файлов. В итоге получаем один отсортированный временный файл, который записываем в итоговый конечный файл. 
2. Реализована функция to_json(obj). В зависимости от объекта вызываются разные функции, которые преобразуют объект в строку json.
3. Реализован класс Nvector, перегружены функции __init__, __sub___, __add__, __mul__ (в зависимости от other выполняет либо скалярное умножение, либо умножение на константу),
 __eq__, __len__, get, scalar_product(скалярное произведение с косинусом), __str__.
4. Декоратор реализован в виде отдельного класса Memoized. В данном классе перегружены методы __init__(принимает функцию func, которую будет декорировать; 
объявляет словарь cache; принимает параметр по умолчанию cache_size, который изначально =8), __call__(проверяет, хэшируемые ли аргументы (если нет, то вызывает основную функцию func); 
проверяет, есть ли в словаре cache значение по заданному ключу, если нет, то вызывает основную функцию func и записывает ее результат в словарь, 
если да, то просто возвращает значение из словаря).
5. Использовала модуль unittest. На каждое задание по 2+ теста(корректная и некорректная работа), покрытие в среднем около 90 процентов. 
6. Реализована функция from_json. Последовательно читается каждый символ в строке и в зависимости от того, какой он, используются функции, 
преобразующие строку в словарь/список/простой тип (строка, bool, None, число). Для нее тоже написаны 2 теста.
7. Синглтон реализован отдельным классом, в котором есть поле _instance. Перегруженная функция __call__ проверяет, есть ли у _ instance значение. 
Данный класс является метаклассом для класса Car, который определен ниже. Еще ниже показана работа паттерна (обе машины будут иметь марку форд).
